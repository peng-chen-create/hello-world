0.12:03的时候，先pop掉的是1，2，4 然后再pop的3 ，那么顺序不就是1243了么，不是就错了吗？？ 请解释，这里我看不懂了  （二叉树的中序遍历非递归写法（集中））
学员的问题是他们普遍把出栈的顺序当成中序遍历的顺序，这里需要强调
                                        5
                                   3       8
                               2     4                            
                           1
刚开始  5 3 2 1
            5 3 2           （1出栈）
            5 3              （2出栈）
            5 3 4             （这里学员的问题集中应该先把3先出栈再把4入栈（因为3的左子树已经遍历完），他们把出栈的顺序当成了中序遍历的顺序，课件的意思是把3保留在栈里往右边走）   
 

1.  为什么是A[left] < pivot 而不是 A[left] <= pivot    							快速排序
防止死循环

2.  为什么内层循环还有while(left <= roght) 是不是多余了  							快速排序
为了防止内层越界

3.请问一下为什么对pivot左右整体排序之后，最后是对start到right、left到end之间再进行排序呢                                                 快速排序
因为我的排序条件是left<=right,当不满足条件时left在right的右边，right在left的左边 

3.  什么是滚动数组，什么情况下用滚动数组                                                        					滚动数组
一种空间优化的方法，当前结果依赖前几个结果，并且前面的结果后面不需要用到

4.is_palindrom[i][i-1] = True 那里之前不是已经规定了s如果是空串return “” 了么， 为什么爱要判定空串                                最大回文子串基于动态规划的做法
因为一开始判断的空串是指给的s本身就是空的，但是左边python的代码在实现时，在 j=i+1时，有一步转移是,dp[i][j] = dp[i+1][j-1],有可能会出现 i+1>j-1的情况，也就是对于一个串“aa“来说，他是从空串“”和前后的“a”转移过来的，这一步转移需要定义dp[i][i-1]=True。

4.dp[i][0] = true这个不理解，前i个数为什么能凑出0的和呢？只有0个数才能凑出0啊，任何大于0的数都只能凑出大于0的数啊？  背包    
   请问dp[i][0]=True表示 前i个数凑和为0肯定可以？ 为什么可以呢，前i个数的和肯定超过0了啊
背包的动态转移方程

5.老师请问自顶向下方法为什么是return dp[m-1][n-1]而不是dp[m][n]呢？                                                                                背包
因为我们是从0,0开始计算的，所以最后就是n-1,m-1

6.为什么快速选择是n+n/2+....是O(n), 二分法也是n+n/2+...就是O(logn)   						二分和分治的区别
二分是砍掉一半数据，而分治是把数据分开，分而治之

7.栈什么时候会炸溢出                       									栈空间
不超出10万

8. 什么是深拷贝，什么是浅拷贝，什么情况下要做深度拷贝呀？                                                                                                  拷贝问题
深拷贝是new一段新的空间，把源数据放进去.    

9.这个31是哪来的，有两个问题， 1. 如果把他弄成constant变量应该叫什么？2. 要不用31还可以用哪些数？                               
31是为了计算机算的快

10.stack.peek().right == node這邊講得不明白                                                                                                                          二叉树中序遍历的非递归实现                                            
这里是为了判断当前节点的右节点遍历了没有

11.什么是稳定排序，什么是不稳定排序                                                                                                                                      快速排序与归并排序                                                

12.为什么一定要避免全局变量呢？使用全局变量可以避免参数的拷贝，以及减少压栈的内容。                                                               

13.如果拓扑排序有环，感觉BFS会进入死循环，不会结束。这里怎么理解结束条件？                                                                    拓扑排序 
如果有环，那么有环的这几个点的入度都不会为0，这样就会导致他们每个都不会被遍历到，此时拓扑排序就结束了。所以拓扑排序的结束条件是要不存在入度为0且未访问的点

14.怎么去判断从上到下还是从下到上？这个题也可以用从上到下的办法解吗？                                                                             动态规划

15.链表题目什么时候加dummy，什么时候不加？                                                                           			链表
链表题都加dummy，这样可以不用考虑特殊情况

16,为什么python 7%5=2，而  -7%5=-3，
python的整数除法是向下取整的，-7//5=-2,向下去取整余数是3，python中余数a%b=c，则b,c同号
 
17.subset子集问题为什么要排序                                                                                                                                               子集

18.480二叉树的所有路径 ,376，二叉树的路径和，第一个用string记录路径“1->2->3”第二个用list记录
[1,2,3]学员问题为什么第一个不需要pop，第二个需要pop 							二叉树
地址问题，传参

19 时间复杂度是O（n^2^1/2)就是O（n)吗； n是grid边长

20，如果的DP公式优化的方向改成了最大化价值，这里是怎么确保前i个物品的体积不超过j的呢？				背包

21，不是很明白为啥A的下标是i - 1而不是i，而前面dp里面对应是i？

22，为什么这里前面的i - 1没用过就continue呢？如果出现重复的数字，前面的数字没用过，不是代表现在这个数字可用吗？
那请问第一种subset的方法是不是不包含自己手动回溯？

23，除了背包问题，哪些题型得设 dp 为 [n + 1][m+1]?
为什么不是，挑选若干数之和 < = X且和最大 = 尽可能塞满一个x的背包？

24，28行代码的 i > startIndex 实在没听懂，为什么i > startIndex 就说明前面的数已经被放过了呢 或者说在这里i 和 startIndex 分别代表了什么呢
results.add(new ArrayList<Integer>(subset));为什么这里需要hard copy呢，如果直接加subset进去不可以吗？

25，但是遍历访问过的点的过程是否可以“共用”呢？比如说我找到两种方案，分别是1-2-3-4-5, 1-2-3-5-4，那么在搜索树中，1-2-3这个部分其实只走了一遍，所以找出这两种方案的时间不是2n，而是n+2。所以遍历每种方案的时间是不是小于O(n)？


26，在后面的视频中说暴力搜索的时间复杂度为O(n!*n)，但是这里并没有像permuations那道题那样去把方案复制一遍加入results的操作，所以构造每种方案不需要O(n)时间，为什么要乘n呢？


27，为什么是临界矩阵的size是[n +1][n +1]，而不是[n][n]呢 									内存分布

28，stack.peek().right == node這邊講得不明白                    									树的中序遍历                														

29，剪枝的时间复杂度优化了吗									

30，为什么取模运算可以拆开算，其中原理是什么？

31.子集（可能重复）问题为什么要i>0

32.克隆图为什么问题真的多..........最多为什么要这样做
1.找到所有点
2.克隆所有点
3.连接所有边

33.如何理解visited数组，回溯的关键，判断选了没有

34.


虽然第一种算法的效率更高，但是两种算法是同一种时间复杂度把？都是 O(n*m) ? 那么，造成性能差异的只是时间复杂度的系数了把？
为什么graph矩阵的长度是n+1而不是n？
自顶向下感觉是greedy的思想？
为什么前面的数没用过就要跳过呢？
"def dfs(self, nums, index, subset, res):
        if index == len(nums):
            res.append(list(subset))
            return
第三行代码为什么list(subset)就是对的，而subset就是错的呢 两个结果有什么区别吗"
startIndex最小是0，如果把i > startIndex放在第一个条件，那么i = 0时条件不满足就不会去判断nums[i]  == nums[i-1]，就不会越界了，所以i != 0是否多余
动态规划是不是空间复杂度很高啊？动不动就是二维数组
写dfs函数的时候，参数需要这样每个单独放置在一行吗？

假设hash(a) 和hash(b) 产生形同的哈希值，他们存到哈希表中以队列的形式存在， 那哈希表如何读取a和b对应的值呢？例如如何判断a对应的是链表中的第一个元素还是第二个元素？
和箭头的那种方式有啥区别啊
为什么用38秒的那种方式可以优化呢？？
怎么控制栈的深度呢
这里的意思是A函数调用完a,b，从栈中push出来，重新压B函数a,b值进去吗？？ 这是怎么实现的呀
还是不明白为什么要从后往前推，而不是从前往后推
为什么是2^n个呢？
把 i > starindex 放到nums[i] == nums[i-1] 前面 就不需要判断i!=0 了
open hashing是不是只能查询有没有value,而不能知道某个key对应的具体时间链表中哪个value
这里应该是字母之后任意一个char 的位置吧
您好，方便发一个cpp版本的吗
我把电脑声音调到最大都听不清老师说的啥啊
dp[num] 怎么会比dp[factor] 小呢






